# Other Question

### 项目架构介绍

## Mysql

[https://zronghui.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-MYSQL45%E8%AE%B2-%E7%AC%94%E8%AE%B0.html](https://zronghui.github.io/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-MYSQL45%E8%AE%B2-%E7%AC%94%E8%AE%B0.html)

### 索引怎么优化

合索引的列是出现在where子句中的列，或者连接子句中指定的列； 2）基数较小的类，索引效果较差，没有必要在此列建立索引； 3）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间； 4）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。

前导模糊查询不能命中索引： EXPLAIN SELECT \* FROM user WHERE name LIKE '%s%';

1. InnoDB Buffer size 足够的情况下，即所有数据与索引能完成全加载进内存，查询不会有大问题。如不能会引发内存-硬盘数据交换，看硬盘IO就知道交换频率了。 一般IO在50%以下，性能也不会有大问题。如果 IO到达 100%，整个MySQL不响应的很可能会发生。当然如有其它数据在另一个硬盘，旧连接是不影响的--前提是没有使用swap。当然，带索引的同一语句，也有可能出现非常小量小量的一次慢--原因不明。2. 单表数据过大，维护确实是非常痛苦，alter就别想了；基本上不可能热备，甚至冷备也不可能-- Innodbbackex除外。 3.  大量的sum与count操作 ，即使where条件有索引，对IO也会比小表大1倍。原因不太清楚，曾经有位有装13经验的人跟我说是索引引起IO--- 我想不明白，索引都load到内存了，如何会有IO？一个行数13亿的表，不一定比1亿的表大。还要看表结构。 总体来讲，我认为影响 应该是表+索引 是否能完全装裁到内存。 而当13E行的表分成1024个小表后，这时sum落到是1/1024表中，我理解是单次的IO时间小，并发qps不变的情况下，总IO降了1倍--这个是实际生产环境数据。4.  高IO会引发雪崩，搞不好整个MySQL挂掉。单硬盘安全峰会IO最好在30%以下。

### 一亿条数据查询优化

以主键水平分割表！

如果一年前的只是备份待查,分离出来另存. 如果一年前的会用到,但用得少,用分区. 如果一年前的仍然要频繁使用,用分区,但要加一个磁盘.

### 横向纵向分表

首先存储引擎的使用不同，冷数据使用MyIsam 可以有更好的查询数据。活跃数据，可以使用Innodb,可以有更好的更新速度。 其次，对冷数据进行更多的从库配置，因为更多的操作时查询，这样来加快查询速度。对热数据，可以相对有更多的主库的横向分表处理。 其实，对于一些特殊的活跃数据，也可以考虑使用memcache ,redis 之类的缓存，等累计到一定量再去更新数据库。或者mongodb 一类的nosql数据库，这里只是举例，就先不说这个。 横向分表 字面意思，就可以看出来，是把大的表结构，横向切割为同样结构的不同表，如，用户信息表，user\_1,user\_2等。表结构是完全一样，但是，根据某些特定的规则来划分的表，如根据用户ID来取模划分。 分表理由：根据数据量的规模来划分，保证单表的容量不会太大，从而来保证单表的查询等处理能力。

### 存储引擎对比



### 学号姓名课程成绩计算总分后倒序排序，找出各科及格的学号姓名

### 事务隔离级别

1. 读未提交 （脏读）
2. 读提交  （不可重复读）
3. 可重复读
4. 串行

## Redis

### 基础结构

1. 字符串
2. List 列表
3. Hash 字典
4. Set集合
5. Sorted Set 有序集合

### 跳表原理

**12、什么是乐观锁和悲观锁**

1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将**比较-替换**这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。

2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

## 算法

### Fibbinacci数列

### 链表有无环

### 树（前序，中序，后序遍历）

### 归并排序 冒泡排序

### 开根号

### Hash碰撞

哈希（Hash）算法，即散列函数。它是一种单向密码体制，即它是一个从明文到密文的不可逆的映射。哈希函数可以将任意长度的输入经过变化以后得到固定长度的输出。哈希函数的这种单向特征和输出数据长度固定的特征使得它可以生成消息或者数据。

### Hash算法用途

1.数据校验

2.唯一标识

3.哈希表

4.负载均衡

{% embed url="https://5.分布式存储" %}

### 避免Hash碰撞策略

#### 1.开放地址法\(再散列法\)

开放地执法有一个公式:Hi=\(H\(key\)+di\) MOD m i=1,2,…,k\(k&lt;=m-1\) 其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…kk,-kk\(k&lt;=m/2\)，称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。

#### 2.再哈希法Rehash

当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止.这种方法不易产生聚集，但增加了计算时间。

#### 3.链地址法（拉链法）

将所有关键字为同义词的记录存储在同一线性链表中.基本思想:将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。对比JDK 1.7 hashMap的存储结构是不是很好理解。至于1.8之后链表长度大于6rehash 为树形结构不在此处讨论。

#### 拉链法的优缺点

#### 优点：

①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元\(即开放地址\)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。

#### 缺点：

指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。

#### 4.建立一个公共溢出区

假设哈希函数的值域为\[0,m-1\],则设向量HashTable\[0..m-1\]为基本表，另外设立存储空间向量OverTable\[0..v\]用以存储发生冲突的记录。

## Http Tcp

### 网页从输入链接到返回页面经历了什么？

简单说说，浏览器根据请求的url交给dns域名解析，查找真正的ip地址，向服务器发起请求；服务器交给后台处理后，返回数据，浏览器会接收到文件数据，比如，html,js，css，图像等；然后浏览器会对加载到的资源进行语法解析，建立相应的内部数据结构；载入解析到得资源文件，渲染页面，完成显示页面效果。

### 三次握手四次挥手



> 第一次挥手

主动关闭的一方，发送一个FIN\(上述讲过---当FIN=1，表示此报文段是一个释放连接的请求报文\)，传送数据，用来告诉对方（被动关闭方），说不会再给你发送数据了。---主动关闭的一方可以接受数据。

> 第二次挥手

被动关闭方 收到 FIN 包，发送 ACK 给对方，确认序号。

> 第三次挥手

被动关闭方 发送一个 FIN，关闭方，说我不会再给你发数据了。（你不给我发送数据，我也不给你发送数据了）

> 第四次挥手

主动关闭一方收到 FIN ，发送要给 ACK ，用来确认序号

## IO多路复用

### poll / epoll

### 线程与进程区别

### Hash表实现原理与冲突解决

## rabbitmq

### 作用：削峰，异步

## 实际问题

### 红包1元随机分给M个人

### 合并两个有序列表 从小到大

```text
func merge(nums1 []int, m int, nums2 []int, n int)  {
	temp := make([]int, m)
	copy(temp, nums1)
	j, k := 0, 0
	for i := 0; i < len(nums1); i++ {
		if k >= n {
			nums1[i] = temp[j]
			j++
			continue
		}
		if j >= m {
			nums1[i] = nums2[k]
			k++
			continue
		}
		if temp[j] < nums2[k] {
			nums1[i] = temp[j]
			j++
		} else {
			nums1[i] = nums2[k]
			k++
		}
	}
}
```

消息 =&gt; 交换机 =&gt; 通过绑定的`key` =&gt; 队列 =&gt; 消费者

## 面向对象

**面向对象**的**三大**特性是"封装、"多态"、"继承"，五大原则是"单一职责原则"、"开放封闭原则"、"里氏替换原则"、"依赖倒置原则"、"接口分离原则"、"迪米特原则（高内聚低耦合）"。

### 微服务

其中软件由通过明确定义的 API 进行通信的小型独立服务组成。这些服务由各个小型独立团队负责。



### 微服务的特点

1. 单一职责 每个微服务都需要满足单一职责原则，微服务本身是内聚的，因此微服务通常比较小。比如示例中每个微服务按业务逻辑划分，每个微服务仅负责自己归属于自己业务领域的功能。
2. 自治 一个微服务就是一个独立的实体，它可以独立部署、升级，服务与服务之间通过REST等形式的标准接口进行通信，并且一个微服务实例可以被替换成另一种实现，而对其它的微服务不产生影响。
3. 简化部署 在一个单块系统中，只要修改了一行代码，就需要对整个系统进行重新的构建、测试，然后将整个系统进行部署。而微服务则可以对一个微服务进行部署。
4. 可扩展 应对系统业务增长的方法通常采用横向（Scale out）或纵向（Scale up）的方向进行扩展。分布式系统中通常要采用Scale out的方式进行扩展。因为不同的功能会面对不同的负荷变化，因此采用微服务的系统相对单块系统具备更好的可扩展性。
5. 灵活组合 在微服务架构中，可以通过组合已有的微服务以达到功能重用的目的。
6. 技术异构 在一个大型系统中，不同的功能具有不同的特点，并且不同的团队可能具备不同的技术能力。因为微服务间松耦合，不同的微服务可以选择不同的技术栈进行开发。 同时，在应用新技术时，可以仅针对一个微服务进行快速改造，而不会影响系统中的其它微服务，有利于系统的演进。
7. 高可靠 微服务间独立部署，一个微服务的异常不会导致其它微服务同时异常。通过隔离、融断等技术可以避免极大的提升微服务的可靠性。
8. 基础设施自动化
9. 服务组件化
10. 容错设计
11. 演进式设计

#### 微服务的缺点

1. 复杂度高 微服务间通过REST、RPC等形式交互，相对于Monolithic模式下的API形式，需要考虑被调用方故障、过载、消息丢失等各种异常情况，代码逻辑更加复杂。 对于微服务间的事务性操作，因为不同的微服务采用了不同的数据库，将无法利用数据库本身的事务机制保证一致性，需要引入二阶段提交等技术。 同时，在微服务间存在少部分共用功能但又无法提取成微服务时，各个微服务对于这部分功能通常需要重复开发，或至少要做代码复制，以避免微服务间的耦合，增加了开发成本。
2. 运维复杂 在采用微服务架构时，系统由多个独立运行的微服务构成，需要一个设计良好的监控系统对各个微服务的运行状态进行监控。运维人员需要对系统有细致的了解才对够更好的运维系统。
3. 影响性能 微服务的间通过REST、RPC等形式进行交互，通信的时延会受到较大的影响。







