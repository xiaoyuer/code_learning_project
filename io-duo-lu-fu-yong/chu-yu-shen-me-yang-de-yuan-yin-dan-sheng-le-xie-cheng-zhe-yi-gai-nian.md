# 出于什么样的原因，诞生了「协程」这一概念？

  


程序开发的一大矛盾是，你要用控制流去完成逻辑流。也就是说，你要用指令的执行来完成逻辑链条的前因后果。

在刚开始学程序的时候，往往都是从控制流等价于执行流的情况下学起，执行到哪，就意味着逻辑走到了哪。这样的程序结构清晰，可读性好。

但是问题是中间有些过程是不能立即得到结果的，程序为了等结果就会阻塞。这种情况多见于一些io操作。为了提升效率，我们可以使用异步的api，通过回调/通知函数来响应操作结果，同时接着执行下一轮的逻辑。

异步回调/通知的问题在于，它把原本统一的逻辑流拆开成了几个阶段，这样控制流和逻辑流就不等价了。为了保证逻辑数据的传递，需要自己来维护状态，阅读起来也比较头疼。状态的维护历来就是bug层出的地方，很容易掉入无效状态而死掉。同时，这种机制调试起来还特别麻烦，因为状态所能提供的信息不够，往往还得手动跟踪调用链，这是相当费精力的。

协程是一种任务调度机制，它可以让你用逻辑流的顺序去写控制流，而且还不会导致操作系统级的线程阻塞。你发起异步请求、注册回调/通知器、保存状态，挂起控制流、收到回调/通知、恢复状态、恢复控制流的所有过程都能过一个yield来默默完成。

从代码结构上看，协程保证了编写过程中的思维连贯性，使得函数（闭包）体本身就无缝保持了程序状态。逻辑紧凑，可读性高，不易写出错的代码，可调试性强。

从实现上看，与线程相比，这种主动让出型的调度方式更为高效。一方面，它让调用者自己来决定什么时候让出，比操作系统的抢占式调度所需要的时间代价要小很多。后者为了能恢复现场会在切换线程时保存相当多的状态，并且会非常频繁地进行切换。另一方面，协程本身可以做在用户态，每个协程的体积比线程要小得多，因此一个进程可以容纳数量相当可观的逻辑流。

举个例子，openresty中的ngx\_lua组件就使用了协程来管理所有的io接口，极大地提升了服务器的负载能力。

2020.5.27 更新：

多线程阻塞的执行图如下：

![](https://pic4.zhimg.com/50/v2-35b14e688fae599083f6a7bbfbe594b1_hd.jpg?source=1940ef5c)

回调的执行图例如下：

![](https://pic1.zhimg.com/50/v2-6c6a24ee6bf8b7899a69b7de1f774e9b_hd.jpg?source=1940ef5c)

带有协程的执行图例如下：

![](https://pic2.zhimg.com/50/v2-6e7d7de3f9517bfd3f96cf3e8532c766_hd.jpg?source=1940ef5c)

从图1可以看出，多线程情形下的多逻辑能力严重依赖于程序申请到的执行流/线程的数量。线程是很重的，不仅体积庞大，还得经常进出内核。在这种模式下，线程的阻塞等待浪费了大量内存。

从图2可以看出，异步回调可以避免忙等，但是逻辑流被拆开了，收到回调之后很难恢复出是从哪里调过来的，逻辑流栈上的变量也被清空了。

图3的协程可以看出，协程不会出现图1这种死等的情况，一但遇到阻塞，那么要么从池子里挑下一个准备好的协程跑，要么由阻塞的协程指定由谁接着它跑，没有CPU时间的浪费。同时相比于图2，逻辑流在程序员看来是连续的，所有的状态都通过原生的栈延续得好好的。

这里要强调一点，协程只是一种任务调度模式，虽然很多情形下是用来解决I/O问题，但它不必然与实际的I/O相关。在上面的方式二中我们可以看出，有时候需要唤醒的下一个逻辑流其实可以通过挂起的逻辑流来指定，这在生产者-消费者模式中非常常见：

生产者生产出产品-&gt;挂起生产者，通知消费者消费-&gt;消费者被唤醒，消费产品-&gt;挂起消费者，通知生产者生产-&gt; ...

在这个模式中，不必有任何实际的I/O，但是通过协程有效地把生产者消费者交替的逻辑解耦了——即无论从生产者还是消费者来看，每方的逻辑流都是流畅且不包含另一方的具体逻辑的。这种模式也是lua的标准协程模式，由于比较少见，特别在这里介绍一下。

